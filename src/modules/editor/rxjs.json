{
  "Rx": {
    "IDisposable": {
      "dispose": "fn()"
    },
    "Disposable": {
      "action": "fn()",
      "isDisposed": "bool",
      "Disposable": "fn(action?: fn()) -> Disposable",
      "dispose": "fn()",
      "create": "fn(action?: fn()) -> Disposable",
      "empty": {
        "dispose": "fn()"
      }
    },
    "SingleAssignmentDisposable": {
      "isDisposed": "bool",
      "current": "Disposable",
      "SingleAssignmentDisposable": "fn() -> SingleAssignmentDisposable",
      "disposable": "fn(value: ?) -> Disposable",
      "getDisposable": "fn() -> Disposable",
      "setDisposable": "fn(value: IDisposable)",
      "dispose": "fn()"
    },
    "CompositeDisposable": {
      "disposables": "[Disposable]",
      "isDisposed": "bool",
      "length": "number",
      "CompositeDisposable": "fn(disposables: [Disposable]) -> CompositeDisposable",
      "add": "fn(item: Disposable)",
      "remove": "fn(item: Disposable) -> bool",
      "dispose": "fn()",
      "clear": "fn()",
      "contains": "fn(item: ?) -> bool",
      "toArray": "fn() -> [Disposable]"
    },
    "SerialDisposable": {
      "isDisposed": "bool",
      "current": "Disposable",
      "SerialDisposable": "fn() -> SerialDisposable",
      "getDisposable": "fn() -> Disposable",
      "setDisposable": "fn(value: Disposable)",
      "disposable": "fn(value: Disposable) -> Disposable",
      "dispose": "fn()"
    },
    "RefCountDisposable": {
      "RefCountDisposable": "fn(disposable: Disposable) -> RefCountDisposable",
      "dispose": "fn()",
      "getDisposable": "fn() -> Disposable"
    },
    "Scheduler": {
      "now": "number",
      "Scheduler": "fn(now: ?, schedule: ?, scheduleRelative: ?, scheduleAbsolute: ?) -> Scheduler",
      "invokeRecImmediate": "fn(scheduler: Scheduler, pair: ?) -> CompositeDisposable",
      "invokeRecDate": "fn(scheduler: Scheduler, pair: ?, method: ?) -> CompositeDisposable",
      "invokeAction": "fn(scheduler: Scheduler, action: fn()) -> Rx.Scheduler.invokeAction.!ret",
      "catchException": "fn(handler: ?) -> CatchScheduler",
      "schedulePeriodic": "fn(period: number, action: fn()) -> Disposable",
      "schedulePeriodicWithState": "fn(state: ?, period: number, action: fn(state: ?)) -> Disposable",
      "schedule": "fn(action: fn()) -> Disposable",
      "scheduleWithState": "fn(state: ?, action: fn(state: ?)) -> Disposable",
      "scheduleWithRelative": "fn(dueTime: number, action: fn()) -> Disposable",
      "scheduleWithRelativeAndState": "fn(state: ?, dueTime: number, action: fn(state: ?)) -> Disposable",
      "scheduleWithAbsolute": "fn(dueTime: number, action: fn()) -> Disposable",
      "scheduleWithAbsoluteAndState": "fn(state: ?, dueTime: number, action: fn(state: ?)) -> Disposable",
      "scheduleRecursive": "fn(action: fn()) -> Disposable",
      "scheduleRecursiveWithState": "fn(state: ?, action: fn(state: ?, action: fn(state: ?))) -> Disposable",
      "scheduleRecursiveWithRelative": "fn(dueTime: number, action: fn()) -> Disposable",
      "scheduleRecursiveWithRelativeAndState": "fn(state: ?, dueTime: number, action: fn(state: ?, action: fn(state: ?, dueTime: number))) -> Disposable",
      "scheduleRecursiveWithAbsolute": "fn(dueTime: number, action: fn(action: fn(dueTime: number))) -> Disposable",
      "scheduleRecursiveWithAbsoluteAndState": "fn(state: ?, dueTime: number, action: fn(state: ?, action: fn(state: ?, dueTime: number))) -> Disposable",
      "normalize": "fn(timeSpan: number) -> number",
      "immediate": "fn() -> Scheduler",
      "currentThread": "fn() -> Scheduler",
      "timeout": "fn() -> Scheduler"
    },
    "IndexedItem": {
      "id": "number",
      "value": "ScheduledItem",
      "compareTo": "fn(other: IndexedItem) -> number"
    },
    "ScheduledItem": {
      "scheduler": "Scheduler",
      "state": "?",
      "action": "fn(scheduler: Scheduler, state: ?) -> Disposable",
      "dueTime": "number",
      "comparer": "fn(x: number, y: number) -> number",
      "disposable": "SingleAssignmentDisposable",
      "invoke": "fn()",
      "compareTo": "fn(other: ScheduledItem) -> number",
      "isCancelled": "fn() -> bool",
      "invokeCore": "fn() -> Disposable"
    },
    "PriorityQueue": {
      "items": "[IndexedItem]",
      "length": "number",
      "isHigherPriority": "fn(left: number, right: number) -> bool",
      "percolate": "fn(index: number)",
      "heapify": "fn(index: number)",
      "peek": "fn() -> IndexedItem",
      "removeAt": "fn(index: number)",
      "dequeue": "fn() -> IndexedItem",
      "enqueue": "fn(item: IndexedItem)",
      "remove": "fn(item: IndexedItem) -> bool"
    },
    "VirtualTimeScheduler": {
      "clock": "number",
      "comparer": "fn(x: number, y: number) -> number",
      "isEnabled": "bool",
      "queue": "PriorityQueue",
      "VirtualTimeScheduler": "fn(initialClock: number, comparer: fn(x: number, y: number) -> number) -> VirtualTimeScheduler",
      "schedulePeriodicWithState": "fn(state: ?, period: number, action: fn(state: ?)) -> Disposable",
      "scheduleRelativeWithState": "fn(state: ?, dueTime: number, action: fn(state: ?)) -> Disposable",
      "scheduleRelative": "fn(dueTime: number, action: fn()) -> Disposable",
      "start": "fn()",
      "stop": "fn()",
      "advanceTo": "fn(time: number)",
      "advanceBy": "fn(time: number)",
      "sleep": "fn(time: number)",
      "getNext": "fn() -> ScheduledItem",
      "scheduleAbsolute": "fn(dueTime: number, action: fn()) -> Disposable",
      "scheduleAbsoluteWithState": "fn(state: ?, dueTime: number, action: fn(scheduler: Scheduler, state: ?) -> Disposable) -> Disposable"
    },
    "CatchScheduler": {},
    "Notification": {
      "hasValue": "bool",
      "accept": "fn(onNext: fn(value: ?), onError?: fn(exception: ?), onCompleted?: fn())",
      "toObservable": "fn(scheduler: Scheduler) -> Internals.AnonymousObservable",
      "equals": "fn(other: Notification) -> bool",
      "createOnNext": "fn(value: ?) -> Notification",
      "createOnError": "fn(exception: ?) -> Notification",
      "createOnCompleted": "fn() -> Notification"
    },
    "Internals": {
      "inherits": "fn(child: Function, parent: Function) -> Function",
      "addRef": "fn(xs: ?, r: ?) -> AnonymousObservable",
      "addProperties": "fn(obj: ?)",
      "AbstractObserver": {
        "isStopped": "bool",
        "onNext": "fn(value: ?)",
        "onError": "fn(error: ?)",
        "onCompleted": "fn()",
        "dispose": "fn()",
        "fail": "fn() -> bool"
      },
      "ScheduledObserver": {
        "scheduler": "Scheduler",
        "observer": "IObserver",
        "isAcquired": "bool",
        "hasFaulted": "bool",
        "disposable": "SerialDisposable",
        "ScheduledObserver": "fn(scheduler: Scheduler, observer: IObserver) -> ScheduledObserver"
      },
      "Enumerator": {
        "Enumerator": "fn(moveNext: fn() -> bool, getCurrent: fn() -> ?, dispose: fn()) -> Enumerator",
        "moveNext": "fn() -> fn() -> bool",
        "getCurrent": "fn() -> fn() -> ?",
        "dispose": "fn() -> fn()",
        "create": "fn(moveNext: fn() -> bool, getCurrent: fn() -> ?, dispose?: fn()) -> Enumerator"
      },
      "Enumerable": {
        "Enumerable": "fn(getEnumerator: fn() -> Enumerator) -> Enumerable",
        "getEnumerator": "fn() -> fn() -> Enumerator",
        "concat": "fn() -> AnonymousObservable",
        "catchException": "fn() -> AnonymousObservable",
        "repeat": "fn(value: ?, repeatCount?: number) -> Enumerable",
        "forEach": "fn(source: Rx.Internals.Enumerable.forEach.source, selector?: fn(element: ?, index: number) -> ?) -> Enumerable"
      },
      "AnonymousObservable": {}
    },
    "ConnectableObservable": {
      "connect": "fn() -> Disposable"
    },
    "IObserver": {
      "isStopped": "bool",
      "onNext": "fn(value: ?)",
      "onError": "fn(error: ?)",
      "onCompleted": "fn()",
      "dispose": "fn()"
    },
    "Observer": {
      "toNotifier": "fn() -> fn(any: ?)",
      "asObserver": "fn() -> IObserver",
      "checked": "fn() -> IObserver",
      "create": "fn(onNext: fn(any: ?), onError?: fn(exception: ?), onCompleted?: fn()) -> IObserver",
      "fromNotifier": "fn(handler: fn(value: ?)) -> IObserver"
    },
    "AnonymousObserver": {
      "AnonymousObserver": "fn(onNext: fn(value: ?), onError: fn(exception: ?), onCompleted: fn()) -> AnonymousObserver",
      "next": "fn(value: ?)",
      "error": "fn(exception: ?)",
      "completed": "fn()"
    },
    "Observable": {
      "Observable": "fn(subscribe: fn(AnonymousObserver: ?) -> Internals.AnonymousObservable) -> Observable",
      "finalValue": "fn() -> Internals.AnonymousObservable",
      "subscribe": "fn(onNext: fn(value: ?), onError?: fn(exception: ?), onCompleted?: fn()) -> IObserver",
      "toArray": "fn() -> Internals.AnonymousObservable",
      "start": "fn(func: Function, scheduler?: Scheduler, context?: Object) -> Internals.AnonymousObservable",
      "toAsync": "fn(func: Function, scheduler?: Scheduler, context?: Object) -> fn() -> Internals.AnonymousObservable",
      "observeOn": "fn(scheduler: Scheduler) -> Internals.AnonymousObservable",
      "subscribeOn": "fn(scheduler: Scheduler) -> Internals.AnonymousObservable",
      "create": "fn(subscribe: fn(observer: AnonymousObserver) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "createWithDisposable": "fn(subscribe: fn(observer: AnonymousObserver) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "defer": "fn(observableFactory: fn() -> ?) -> Internals.AnonymousObservable",
      "empty": "fn(scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "fromArray": "fn(array: [?], scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "generate": "fn(initialState: ?, condition: fn(value: ?) -> bool, iterate: fn(value: ?) -> ?, resultSelector: fn(value: ?) -> ?, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "never": "fn() -> Internals.AnonymousObservable",
      "range": "fn(start: number, count: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "repeat": "fn(repeatCount?: number) -> Internals.AnonymousObservable",
      "returnValue": "fn(value: ?, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "throwException": "fn(exception: Error, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "using": "fn(resourceFactory: fn() -> ?, observableFactory: fn(resource: ?) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "amb": "fn() -> Internals.AnonymousObservable",
      "catchException": "fn(observables: [Internals.AnonymousObservable]) -> Internals.AnonymousObservable",
      "combineLatest": "fn(second: Internals.AnonymousObservable, third: Internals.AnonymousObservable, fourth: Internals.AnonymousObservable, fifth: Internals.AnonymousObservable, resultSelector: fn(v1: ?, v2: ?, v3: ?, v4: ?, v5: ?) -> ?) -> Internals.AnonymousObservable",
      "concat": "fn(observables: [Internals.AnonymousObservable]) -> Internals.AnonymousObservable",
      "concatObservable": "fn() -> Internals.AnonymousObservable",
      "merge": "fn(scheduler: Scheduler, observables: [Internals.AnonymousObservable]) -> Internals.AnonymousObservable",
      "mergeObservable": "fn() -> Internals.AnonymousObservable",
      "onErrorResumeNext": "fn(observables: [Internals.AnonymousObservable]) -> Internals.AnonymousObservable",
      "skipUntil": "fn(other: Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "switchLatest": "fn() -> Internals.AnonymousObservable",
      "takeUntil": "fn(other: Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "zip": "fn(second: [?], resultSelector: fn(left: ?, right: ?) -> ?) -> Internals.AnonymousObservable",
      "asObservable": "fn() -> Internals.AnonymousObservable",
      "bufferWithCount": "fn(count: number, skip?: number) -> Internals.AnonymousObservable",
      "dematerialize": "fn() -> Internals.AnonymousObservable",
      "distinctUntilChanged": "fn(keySelector?: fn(value: ?) -> ?, comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "doAction": "fn(observer: IObserver) -> Internals.AnonymousObservable",
      "finallyAction": "fn(action: fn()) -> Internals.AnonymousObservable",
      "ignoreElements": "fn() -> Internals.AnonymousObservable",
      "materialize": "fn() -> Internals.AnonymousObservable",
      "retry": "fn(retryCount?: number) -> Internals.AnonymousObservable",
      "scan": "fn(seed: ?, accumulator: fn(acc: ?, x: ?) -> ?) -> Internals.AnonymousObservable",
      "skipLast": "fn(count: number) -> Internals.AnonymousObservable",
      "startWith": "fn(scheduler: Scheduler) -> Internals.AnonymousObservable",
      "takeLast": "fn(count: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "takeLastBuffer": "fn(count: number) -> Internals.AnonymousObservable",
      "windowWithCount": "fn(count: number, skip?: number) -> Internals.AnonymousObservable",
      "defaultIfEmpty": "fn(defaultValue?: ?) -> Internals.AnonymousObservable",
      "distinct": "fn(keySelector?: fn(element: ?) -> ?, keySerializer?: fn(key: ?) -> string) -> Internals.AnonymousObservable",
      "groupBy": "fn(keySelector: fn(value: ?) -> ?, elementSelector?: fn(value: ?) -> ?, keySerializer?: fn(key: ?) -> string) -> Internals.AnonymousObservable",
      "groupByUntil": "fn(keySelector: fn(value: ?) -> ?, elementSelector: fn(value: ?) -> ?, durationSelector: fn(group: GroupedObservable) -> Internals.AnonymousObservable, keySerializer?: fn(key: ?) -> string) -> Internals.AnonymousObservable",
      "select": "fn(selector: fn(value: ?, index: number) -> ?) -> Internals.AnonymousObservable",
      "map": "fn(selector: fn(value: ?, index: number) -> ?) -> Internals.AnonymousObservable",
      "selectMany": "fn(selector: fn(value: ?) -> ?, resultSelector?: fn(value: ?, res: ?) -> ?) -> Internals.AnonymousObservable",
      "flatMap": "fn(selector: fn(value: ?) -> ?, resultSelector?: fn(value: ?, res: ?) -> ?) -> Internals.AnonymousObservable",
      "skip": "fn(count: number) -> Internals.AnonymousObservable",
      "skipWhile": "fn(predicate: fn(value: ?, index?: number) -> bool) -> Internals.AnonymousObservable",
      "take": "fn(count: number, scheduler: Scheduler) -> Internals.AnonymousObservable",
      "takeWhile": "fn(predicate: fn(value: ?, index?: number) -> bool) -> Internals.AnonymousObservable",
      "where": "fn(predicate: fn(value: ?, index?: number) -> bool) -> Internals.AnonymousObservable",
      "aggregate": "fn(seed: ?, accumulator: fn(acc: ?, x: ?) -> ?) -> Internals.AnonymousObservable",
      "any": "fn(predicate?: fn(any: ?) -> bool) -> Internals.AnonymousObservable",
      "isEmpty": "fn() -> Internals.AnonymousObservable",
      "all": "fn(predicate?: fn(any: ?) -> bool) -> Internals.AnonymousObservable",
      "contains": "fn(value: ?, comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "count": "fn(predicate?: fn(any: ?) -> bool) -> Internals.AnonymousObservable",
      "sum": "fn(keySelector?: fn(any: ?) -> ?) -> Internals.AnonymousObservable",
      "minBy": "fn(keySelector: fn(value: ?) -> ?, comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "min": "fn(comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "maxBy": "fn(keySelector: fn(value: ?) -> ?, comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "max": "fn(comparer?: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "average": "fn(keySelector?: fn(value: ?) -> ?) -> Internals.AnonymousObservable",
      "sequenceEqual": "fn(second: Internals.AnonymousObservable, comparer: fn(x: ?, y: ?) -> bool) -> Internals.AnonymousObservable",
      "elementAt": "fn(index: number) -> Internals.AnonymousObservable",
      "elementAtOrDefault": "fn(index: number, defaultValue?: ?) -> Internals.AnonymousObservable",
      "single": "fn(predicate?: fn(value: ?) -> bool) -> Internals.AnonymousObservable",
      "singleOrDefault": "fn(predicate?: fn(value: ?) -> bool, defaultValue?: ?) -> Internals.AnonymousObservable",
      "first": "fn(predicate: fn(value: ?) -> bool) -> Internals.AnonymousObservable",
      "firstOrDefault": "fn(predicate?: fn(value: ?) -> bool, defaultValue?: ?) -> Internals.AnonymousObservable",
      "last": "fn(predicate?: fn(value: ?) -> bool) -> Internals.AnonymousObservable",
      "lastOrDefault": "fn(predicate?: fn(value: ?) -> bool, defaultValue?: ?) -> Internals.AnonymousObservable",
      "interval": "fn(period: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "timer": "fn(dueTime: number, period?: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "delay": "fn(dueTime: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "throttle": "fn(dueTime: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "windowWithTime": "fn(timeSpan: number, timeShiftScheduler?: ?, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "windowWithTimeOrCount": "fn(timeSpan: number, count: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "bufferWithTime": "fn(timeSpan: number, timeShiftScheduler?: Scheduler, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "bufferWithTimeOrCount": "fn(timeSpan: number, count: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "timeInterval": "fn(scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "timestamp": "fn(scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "sample": "fn(sampler: Internals.AnonymousObservable, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "timeout": "fn(dueTime: number, other: Internals.AnonymousObservable, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "generateWithAbsoluteTime": "fn(initialState: ?, condition: fn(state: ?) -> bool, iterate: fn(state: ?) -> ?, resultSelector: fn(state: ?) -> ?, timeSelector: fn(state: ?) -> Date, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "generateWithRelativeTime": "fn(initialState: ?, condition: fn(state: ?) -> bool, iterate: fn(state: ?) -> ?, resultSelector: fn(state: ?) -> ?, timeSelector: fn(state: ?) -> number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "delaySubscription": "fn(dueTime: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "delayWithSelector": "fn(subscriptionDelay: Internals.AnonymousObservable, delayDurationSelector: fn(x: ?) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "timeoutWithSelector": "fn(firstTimeout: Internals.AnonymousObservable, timeoutdurationSelector: fn(x: ?) -> Internals.AnonymousObservable, other?: Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "throttleWithSelector": "fn(throttleDurationSelector: fn(x: ?) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "skipLastWithTime": "fn(duration: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "takeLastWithTime": "fn(duration: number, timerScheduler?: Scheduler, loopScheduler?: Scheduler) -> Internals.AnonymousObservable",
      "takeLastBufferWithTime": "fn(duration: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "takeWithTime": "fn(duration: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "skipWithTime": "fn(duration: ?, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "skipUntilWithTime": "fn(startTime: Date, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "takeUntilWithTime": "fn(endTime: Date, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "multicast": "fn(subject: Internals.AnonymousObservable, selector?: fn(source: Internals.AnonymousObservable) -> Internals.AnonymousObservable) -> Internals.AnonymousObservable",
      "publish": "fn(selector?: fn(source: Internals.AnonymousObservable) -> Internals.AnonymousObservable) -> ConnectableObservable",
      "publishLast": "fn(selector?: fn(source: Internals.AnonymousObservable) -> Internals.AnonymousObservable) -> ConnectableObservable",
      "publishValue": "fn(initialValue: ?) -> ConnectableObservable",
      "replay": "fn(selector?: fn(source: Internals.AnonymousObservable) -> Internals.AnonymousObservable, bufferSize?: number, window?: number, scheduler?: Scheduler) -> Internals.AnonymousObservable",
      "and": "fn(right: Internals.AnonymousObservable) -> Pattern",
      "then": "fn(selector: fn() -> ?) -> Plan",
      "when": "fn() -> Internals.AnonymousObservable"
    },
    "GroupedObservable": {
      "key": "?",
      "underlyingObservable": "Internals.AnonymousObservable"
    },
    "InnerSubscription": {
      "observer": "AnonymousObserver",
      "subject": "Subject",
      "InnerSubscription": "fn(subject: Subject, observer: AnonymousObserver) -> InnerSubscription",
      "dispose": "fn()"
    },
    "ISubject": {},
    "Subject": {
      "isDisposed": "bool",
      "isStopped": "bool",
      "observers": "[AnonymousObserver]",
      "Subject": "fn() -> Subject",
      "onNext": "fn(value: ?)",
      "onError": "fn(error: ?)",
      "onCompleted": "fn()",
      "dispose": "fn()"
    },
    "AsyncSubject": {
      "isDisposed": "bool",
      "isStopped": "bool",
      "value": "?",
      "hasValue": "bool",
      "observers": "[AnonymousObserver]",
      "exception": "?",
      "AsyncSubject": "fn() -> AsyncSubject",
      "onNext": "fn(value: ?)",
      "onError": "fn(error: ?)",
      "onCompleted": "fn()",
      "dispose": "fn()"
    },
    "BehaviorSubject": {
      "isDisposed": "bool",
      "isStopped": "bool",
      "value": "?",
      "hasValue": "bool",
      "observers": "[AnonymousObserver]",
      "exception": "?",
      "BehaviorSubject": "fn(value: ?) -> BehaviorSubject",
      "onNext": "fn(value: ?)",
      "onError": "fn(error: ?)",
      "onCompleted": "fn()",
      "dispose": "fn()"
    },
    "ReplaySubject": {
      "bufferSize": "number",
      "window": "number",
      "scheduler": "Scheduler",
      "q": "[?]",
      "observers": "[Internals.AnonymousObservable]",
      "isStopped": "bool",
      "isDisposed": "bool",
      "hasError": "bool",
      "error": "?",
      "ReplaySubject": "fn(bufferSize?: number, window?: number, scheduler?: Scheduler) -> ReplaySubject",
      "onNext": "fn(value: ?)",
      "onError": "fn(error: ?)",
      "onCompleted": "fn()",
      "dispose": "fn()"
    },
    "Pattern": {
      "patterns": "[Internals.AnonymousObservable]",
      "and": "fn(other: Internals.AnonymousObservable) -> Pattern",
      "then": "fn(selector: fn() -> ?) -> Plan"
    },
    "Plan": {
      "expression": "[Internals.AnonymousObservable]",
      "selector": "fn(values: ?) -> ?",
      "activate": "fn(externalSubscriptions: ?, observer: ?, deactivate: ?) -> ActivePlan"
    },
    "ActivePlan": {
      "joinObserverArray": "[JoinObserver]",
      "onNext": "fn(value: ?) -> ?",
      "onCompleted": "fn()",
      "joinObservers": "Map",
      "dequeue": "fn()",
      "match": "fn()"
    },
    "Map": {
      "keys": "[?]",
      "values": "[?]",
      "delete": "fn(key: ?) -> bool",
      "get": "fn(key: ?, fallback: ?) -> ?",
      "set": "fn(key: ?, value: ?)",
      "size": "fn() -> number",
      "has": "fn(key: ?) -> bool",
      "getKeys": "fn() -> [?]",
      "getValues": "fn() -> [?]"
    },
    "JoinObserver": {
      "source": "Internals.AnonymousObservable",
      "queue": "[?]",
      "activePlans": "[ActivePlan]",
      "subscription": "SingleAssignmentDisposable",
      "isDisposed": "bool",
      "next": "fn(notification: ?)",
      "addActivePlan": "fn(activePlan: ActivePlan)",
      "subscribe": "fn()",
      "removeActivePlan": "fn(activePlan: ?)"
    }
  },
  "!name": "rx.d.ts",
  "!define": {
    "Rx.Scheduler.invokeAction.!ret": {
      "dispose": "fn()"
    },
    "Rx.Internals.Enumerable.forEach.source": {
      "length": "number",
      "__item": "fn(index: number) -> ?"
    }
  }
}
